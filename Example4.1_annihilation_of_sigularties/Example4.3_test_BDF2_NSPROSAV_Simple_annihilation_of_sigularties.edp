//---------------------------------------------------------------------------
/*
	Find (u, p, d) satisfying the the nematic-liquid-crystal flows 
	BDF2 + Projection + NS scalar auxiliary variable (NSPROSAV) scheme
	Ruonan Cao, Oct 2023
*/
//--------------------------------------------------------------------- -----

//*****************************************************************************
//**************************** Prepare ****************************************
//*****************************************************************************
verbosity = 0; // to remove all default output; default value is 1
string logname = "test_BDF2_NSPROSAV_sigular.txt";
bool refinmesh = false;

//time information
real dT = 0.0005;  //  time step size; 0.1 is too large for stability !
real T0 = 0.0;    //  initial time
real Tf = 1.0;   //  final time
real PRESSUREPENALTY = 1.0e-20; //1.0e-10;
real t;
real Numdt = Tf / dT ;
//Domain parameters
real H    = 2.;    //width of box (y-direction)
real L    = 2.;     //length of channel (x-direction)
int  Ny   = 32;		//Number of nodes along width of channel
int  Nx   = 32;
int  TotalRefine = 4;
// real aa = 4;
// real dT = aa/(Nx^2);  //  time step size; 0.1 is too large for stability !
//Newton/Picard iteration stopping parameters  
real tolNewton=1.0e-8, tolPicard=1.0e-8;
int maxItrNewton = 20, maxItrPicard = 20;
int numIts;
//physical parameters
real nu =1.0;//0.5;
real M = 1.0;//10.;
real lambda = 0.01;
real eta =0.05;
//initinal parameters
real alp = 0.5;
real aa = 0.5;
real bb = eta;
//initinal parameters
//---------------------------------------------------------------------
//  Output flow details
{
    ofstream report(logname);
    report << " ***   nematic liquid crystal   ***" << endl << endl;
    report << "Numerical scheme: " << endl;
    report << " ***  BDF2 + Scalar auxiliary variable + Projection  : Sigular solution   " << endl;
    report << "PROBLEM SETUP: " << endl;
    report << " Height,            H       = " << H << endl;  
    report << " Length,            L       = " << L << endl;
    report << " # bdry nodes (channel length bottom), N01  = " << Nx << endl;  
    report << " # bdry nodes (channel height right),  N02  = " << Ny << endl;  
    report << "TIME STEPPING DATA: " << endl;
    report << "  Time step size,               dT = " << dT << endl;
    report << "  Initial time,                 T0 = " << T0 << endl;
    report << "  Final time,                   Tf = " << Tf << endl;
    report << "  Max iterations,           maxItrNewton = " << maxItrNewton << ", maxItrPicard = " << maxItrPicard<< endl;
    report << "  Error tolerance,        tolNewton = " << tolNewton << ", tolPicard = " << tolPicard << endl;
    report << "PROBLEM PARAMETERS: " << endl;
    report << "Fluid viscosity,         nu = " << nu << ", M = " << M << endl;
	report << "Parameter: " << "lambda = " << lambda << ", eta= " << eta <<endl;
    report << "SOLVER OPTIONS: " << endl;
}



//*********** Initial Condition ********************************************************
func dmaoX =x^2+y^2-alp^2;
func dmaoY =2.0*aa*y;

func real dirXinitial(real x, real y)
{
     return ( dmaoX/sqrt(dmaoX^2+dmaoY^2+bb^2) ) ;
}
func real dirYinitial(real x, real y)
{
     return ( dmaoY/sqrt(dmaoX^2+dmaoY^2+bb^2) ) ;
}
func uXinitial = 0.0 ;
func uYinitial = 0.0 ;

//**********************************************************************************************
//**********************************************************************************************
//********* Construct mesh (fluid region only) ***********************
mesh ThF = square(Nx, Ny, [x*L-1.0, y*H-1.0]);
//plot (ThF,wait=1);
//********************************************************************
real[int] h(TotalRefine+1);
real[int] errorUL2(TotalRefine+1),     errorUH1semi(TotalRefine+1);
real[int] errorDL2(TotalRefine+1),   errorDH1semi(TotalRefine+1);
real[int] errorPL2(TotalRefine+1),     errorPH1semi(TotalRefine+1);
real[int] errorPiniL2(TotalRefine+1),   errorPiniH1semi(TotalRefine+1);
real[int] energy(Numdt+1),  orienergy(Numdt+1);
real[int] Epen(Numdt+1);
real[int] Ekin(Numdt+1),    Eelas(Numdt+1);
real rr , rrold , rroldold , V , A , B ;
//********************************************************************
//FE-spaces
//Velocity space, C0- piecewise quadratic
fespace Uh(ThF,P2);
//Pressure space, C0- piecewise linear
fespace Ph(ThF,P1);
//fe-functions (velocity space)
// uX,     uY     = current time-step
// uXold,  uYold  = previous time-step (u^n)
// uXoldold, uYoldold = second previous time-step (u^{n-1})
// uXTemp, uYTemp = previous nonlinear-iterate corresponding to current time-step solution (uX, uY)
Uh uX, uY, uXold, uYold, uXoldold, uYoldold, uXtemp, uYtemp, uhatX, uhatY, ubreveX, ubreveY;
Uh ustarX, ustarY, ustarhatX, ustarhatY, ustarbreveX, ustarbreveY;
Uh utildeX, utildeY,unorm;
//fe-functions (orientation space)
Uh dirX, dirY, dirXold, dirYold, dirXoldold, dirYoldold, dirXoldoldold, dirYoldoldold, dirhatX, dirhatY, dirbreveX, dirbreveY;
Uh dirtildeX, dirtildeY, dirbarX, dirbarY, dirmaoX, dirmaoY,dirnorm;
//fe-functions (orientation, newton update functions)
Uh dirXtemp, dirYtemp, rX, rY;
//fe-functions (chemical potential, linear variable)
Uh whatX, whatY, wbreveX, wbreveY, wX, wY, wXold, wYold, wXoldold, wYoldold;
Uh wtildeX, wtildeY;		
//fe-functions (velocity space, test functions)
Uh vX, vY;
//fe-functions (orientation space, test functions)
Uh psiX, psiY;
//
Ph Hfunc, Hfuncold, g, gold;
//fe-functions (pressure space)
// p     = pressure at current time-step
// pold  = pressure at previous time-step (p^n)
// poldold = pressure at second previous time-step (p^{n-1})
// pTemp = previous nonlinear-iterate corresponding to current time-step solution p
Ph p, pold, poldold, ptemp, phat, pbreve, qq, qqold, qqoldold;
//fe-functions (pressure space, test functions)
Ph q;

Ph hValue = hTriangle;
//solution at final time
Uh uXtf, uYtf, dirXtf, dirYtf;		// uXtf, uYtf = solution at final time
Ph ptf;		


//********************************************************************
//********************************************************************
//********************************************************************
//Define coHaon expressions via macros:
macro div(u1,u2) ( dx(u1) + dy(u2) ) // \nabla\cdot u
macro dot(u1,u2,v1,v2) ( u1 * v1 + u2 * v2 ) // u\cdot v
macro Ugradv1(u1,u2,v1) ( u1 * dx(v1) + u2 * dy(v1) ) // u\cdot\nabla v
macro cc(u1,u2,v1,v2,w1,w2) ( Ugradv1(u1,u2,v1) * w1 + Ugradv1(u1,u2,v2) * w2 ) // (u\nabla)v\cdot w
macro cch(u1,u2,v1,v2,w1,w2) ( 0.5*(cc(u1,u2,v1,v2,w1,w2) - cc(u1,u2,w1,w2,v1,v2)) ) //  (u\cdot\nabla)v\cdot w
macro contract(u1,u2,v1,v2) ( dx(u1) * dx(v1) + dx(u2) * dx(v2) + dy(u1) * dy(v1) + dy(u2) * dy(v2) ) // \nabla u\cdot\\nable v
macro ss(u1,u2,v1,v2) ( dot(dx(v1),dy(v1),dx(v1),dy(v1)) * u1 + dot(dx(v1),dy(v1),dx(v2),dy(v2)) * u2 ) //(\nabla d)^t u\cdot\nabla d
macro ssh(u1,u2,v1,v2,w1,w2) ( ss(u1,u2,v1,v2) * w1 + ss(u2,u1,v2,v1) * w2 ) //(\nabla d)^t u\cdot\nabla d\cdot v
macro lapa1(u1,u2) ( dxx(u1) + dxy(u2) )// \nabla(\nabla\cdot u)
macro lapa2(u1,u2) ( dyx(u1) + dyy(u2) )// \nabla(\nabla\cdot u)

//**********************************************************************************
//************ Solve for dhat **************************************************
//**********************************************************************************
problem solveDhat([dirhatX, dirhatY], [psiX, psiY], solver=UMFPACK)=
	int2d(ThF)(
		  1.5* dot(dirhatX, dirhatY, psiX, psiY)/ dT
		+ M* contract(dirhatX, dirhatY, psiX, psiY)
		+ 2.0* M/ eta^2* dot(dirtildeX, dirtildeY, dirhatX, dirhatY)* dot(dirtildeX, dirtildeY, psiX, psiY)
	)
   +int2d(ThF)(
		- 2.0* dot(dirXold, dirYold, psiX, psiY)/ dT
		+ 0.5* dot(dirXoldold, dirYoldold, psiX, psiY)/ dT
		- 8.0* M/ (3.0* eta^2)* dot(dirtildeX, dirtildeY, dirXold, dirYold)* dot(dirtildeX, dirtildeY, psiX, psiY)
		+ 2.0* M/ (3.0* eta^2)* dot(dirtildeX, dirtildeY, dirXoldold, dirYoldold)* dot(dirtildeX, dirtildeY, psiX, psiY)
		+ 4.0* M/ 3.0* dot(dirtildeX, dirtildeY, psiX, psiY)* qqold
		- 1.0* M/ 3.0* dot(dirtildeX, dirtildeY, psiX, psiY)* qqoldold
	);


//**********************************************************************************
//************ Solve for dbreve **************************************************
//**********************************************************************************
problem solveDbreve([dirbreveX, dirbreveY], [psiX, psiY], solver=UMFPACK)=
	int2d(ThF)(
		  1.5* dot(dirbreveX, dirbreveY, psiX, psiY)/ dT
		+ M* contract(dirbreveX, dirbreveY, psiX, psiY)
		+ 2.0* M/ eta^2* dot(dirtildeX, dirtildeY, dirbreveX, dirbreveY)* dot(dirtildeX, dirtildeY, psiX, psiY)
	)
   +int2d(ThF)(
		  cc(utildeX, utildeY, dirtildeX, dirtildeY, psiX, psiY)
	);

 
//**********************************************************************************
//************ Solve for ustarhat **************************************************
//**********************************************************************************
problem solveUstarhat([ustarhatX, ustarhatY], [vX, vY], init=1, solver=UMFPACK)=
	int2d(ThF)(
		 1.5* dot(ustarhatX, ustarhatY, vX, vY)/ dT
		+ nu* contract(ustarhatX, ustarhatY, vX, vY) 
	)
   +int2d(ThF)(
		- 2.0* dot(uXold, uYold, vX, vY)/ dT
		+ 0.5* dot(uXoldold, uYoldold, vX, vY)/ dT
		+ dx(pold)* vX+ dy(pold)* vY
	)
 +on(1,2,3,4, ustarhatX = 0.0, ustarhatY = 0.0) ; 
	
	
//**********************************************************************************
//************ Solve for ustarbreve **************************************************
//**********************************************************************************
problem solveUstarbreve([ustarbreveX, ustarbreveY] , [vX, vY], init=1, solver=UMFPACK)=
	int2d(ThF)(
		 1.5* dot(ustarbreveX, ustarbreveY, vX,vY)/dT
		+ nu* contract(ustarbreveX, ustarbreveY, vX, vY)
	)
   +int2d(ThF)(
		- lambda* cc(vX, vY, dirtildeX, dirtildeY, wtildeX, wtildeY)
		+ cc(utildeX, utildeY, utildeX, utildeY, vX, vY)
	)
+on(1,2,3,4, ustarbreveX = 0.0, ustarbreveY = 0.0) ;	
 
//**********************************************************************************
//************ Solve for Phat **************************************************
//**********************************************************************************

problem solvePhat(phat, q, init=1, solver=UMFPACK)=
	int2d(ThF)(- dx(phat)*dx(q) - dy(phat)*dy(q)
	) 
   +int2d(ThF)( 
		  dx(pold)* dx(q)+ dy(pold)* dy(q)
		- 1.5* div(ustarhatX, ustarhatY)* q/ dT
		- nu* lapa1(ustarhatX, ustarhatY)* dx(q)
		- nu* lapa2(ustarhatX, ustarhatY)* dy(q)
	); 
	

//**********************************************************************************
//************ Solve for Pbreve **************************************************
//**********************************************************************************

problem solvePbreve(pbreve, q, init=1, solver=UMFPACK)=
	int2d(ThF)(- dx(pbreve)*dx(q) - dy(pbreve)*dy(q)
	) 
   +int2d(ThF)( 
		 - 1.5* div(ustarbreveX, ustarbreveY)* q/ dT
		 - nu* lapa1(ustarbreveX, ustarbreveY)* dx(q)
		 - nu* lapa2(ustarbreveX, ustarbreveY)* dy(q)
	);
	
//**********************************************************************************
//************ Solve for ustarhat **************************************************
//**********************************************************************************
problem solveUhat([uhatX, uhatY] , [vX, vY], init=1,  solver=UMFPACK)=
	int2d(ThF)(
		  dot(uhatX, uhatY, vX,vY)
	)
   +int2d(ThF)(
		- dot(ustarhatX, ustarhatY, vX,vY)
		+ 2.0*dT/3.0*dot(dx(phat),dy(phat), vX,vY)
		- 2.0*dT/3.0*dot(dx(pold),dy(pold), vX,vY)
		+ 2.0*dT/3.0*nu*lapa1(ustarhatX,ustarhatY)*vX
		+ 2.0*dT/3.0*nu*lapa2(ustarhatX,ustarhatY)*vY
	)
+on(1,3, uhatY = 0.0) 
+on(2,4, uhatX = 0.0) ;	

problem solveUbreve([ubreveX, ubreveY] , [vX, vY], init=1, solver=UMFPACK)=
	int2d(ThF)(
		  dot(ubreveX, ubreveY, vX,vY)
	)
   +int2d(ThF)(
		- dot(ustarbreveX, ustarbreveY, vX,vY)
		+ 2.0*dT/3.0*dot(dx(pbreve),dy(pbreve), vX,vY)
		+ 2.0*dT/3.0*nu*lapa1(ustarbreveX,ustarbreveY)*vX
		+ 2.0*dT/3.0*nu*lapa2(ustarbreveX,ustarbreveY)*vY
	)
+on(1,3, ubreveY = 0.0) 
+on(2,4, ubreveX = 0.0) ;	
	
//*************************************************************************************************
//*******************************************************************************
//******** First Order IMEX Euler for the First Step ****************************
//*******************************************************************************
//Newton linearized increment equation, need dirXtemp, dirYtemp (prev newton update), dirXold, dirYold (time evolution), uXtemp, uYtemp (prev picard update)
problem ACNewton1st([rX, rY], [psiX, psiY], solver= UMFPACK) =
   int2d(ThF)(
      (1.0 / dT) * dot(rX, rY, psiX, psiY) 
    + M * contract(rX, rY, psiX, psiY)
    + M / (eta^2) * 3.0 * dot(dirXtemp, dirYtemp, dirXtemp, dirYtemp) * dot(rX, rY, psiX, psiY)
   )
 + int2d(ThF)(
      (1.0 / dT) * dot(dirXtemp, dirYtemp, psiX, psiY)
    - (1.0 / dT) * dot(dirXold, dirYold, psiX, psiY)
    + cc(uXtemp, uYtemp, dirXold, dirYold, psiX, psiY)
    + M * contract(dirXtemp, dirYtemp, psiX, psiY)
    + M / (eta^2) * dot(dirXtemp, dirYtemp, dirXtemp, dirYtemp) * dot(dirXtemp, dirYtemp, psiX, psiY)
    - M / (eta^2) * dot(dirXold, dirYold, psiX, psiY)     //- lambda * M / (eta^2) * phitemp * psi
   );

//Picard iteration for NS, need uXold, uYold (time evolution), dirXold, dirYold (time evolution), dirX, dirY (time evolution, last newton update)
problem NSPicard1st([uX,uY,p],[vX,vY,q], solver=UMFPACK) =
   int2d(ThF)(
      (1.0 / dT) * dot(uX,uY,vX,vY)
    + cch( uXold, uYold, uX, uY, vX, vY)
    + nu * contract(uX, uY, vX, vY)
    - p * div(vX, vY)
	+ q * div(uX, uY)
    - PRESSUREPENALTY * p * q
    + lambda / M * ssh( uX , uY , dirXold , dirYold , vX, vY )
   )
 + int2d(ThF)(
    - (1.0 / dT) * dot(uXold,uYold,vX,vY)
    + lambda / (dT*M) * cc(vX, vY, dirXold, dirYold, dirX, dirY)
    - lambda / (dT*M) * cc(vX, vY, dirXold, dirYold, dirXold, dirYold) 
   )
 +on( 1,2,3,4, uX = 0.0, uY = 0.0 ) ;



//*************************************************************************************************
//*********** Main SOLVE (Artificial Compression + SAV) ****************
//*************************************************************************************************
real    tmpPH1err, error, errorp, tmpUH1err, tmpUH1norm; //temporary holder for error at each Newton/Picard iteration
uXtf = 0.0;
uYtf = 0.0;
dirXtf = 0.0;
dirYtf = 0.0;
ptf  = 0.0;

real area = int2d(ThF)(1.0);
    

//*************************************************************** 
//********** Initialize *****************************************
//***************************************************************
t = T0;

uX = uXinitial(x,y);
uY = uYinitial(x,y);
p  = 0.0; //fake, not using initStokes
dirX = dirXinitial(x,y);
dirY = dirYinitial(x,y);
qq = 1.0/eta^2 * (dirX^2 + dirY^2 - 1.0);
rr = exp(-t/Tf);
wX = -( dxx(dirX)+dyy(dirX) ) + qq*dirX ;
wY = -( dxx(dirY)+dyy(dirY) ) + qq*dirY ;
//plot([uX,uY], cmm=logname + " velocity, " + "time level = " + t, value=1);
//plot(p, cmm=logname + " Phase variable, " + "time level = " + t, value=1, fill=1);
g = 0.0;
Hfunc = g + p;

//Save phi
include "ffmatlib.idp"
 //Save mesh
savemesh(ThF,"BDFPROSAVdir.msh");
//Save finite element space connectivity
ffSaveVh(ThF,Uh,"BDFPROSAVThF_Uh.txt");
//Save a 2D vector field
ffSaveData2(dirX,dirY,"BDFPROSAVdir_t0.txt");
//Save a 2D vector field
ffSaveData2(uX,uY,"BDFPROSAVu_t0.txt");

// orienergy(0) = int2d(ThF)( 0.5*(uX^2+uY^2) + 0.5*lambda*(dx(dirX)^2+dy(dirX)^2+dx(dirY)^2+dy(dirY)^2) + lambda*eta^2*0.25*qq^2);
// energy(0) = int2d(ThF)(
				  // 0.5*lambda*(dx(dirX)^2+dy(dirX)^2+dx(dirY)^2+dy(dirY)^2) + lambda*eta^2*0.25*qq^2 
				// + 0.5*(uX^2+uY^2) + 0.5*dT^2*(dx(p)^2+dy(p)^2) 
				// )
				// + 0.5*lambda*rr^2;	
// Ekin(0) = int2d(ThF)( 0.5*(uX^2+uY^2) );
// Eelas(0)= int2d(ThF)( 0.5*lambda*(dx(dirX)^2+dy(dirX)^2+dx(dirY)^2+dy(dirY)^2) );
// Epen(0) = int2d(ThF)( lambda*eta^2*0.25*qq^2 );

// cout << "at t = " << t << ", Energy = " << energy(0) << endl;
cout << "INitialize_time" <<endl;
plot([dirX,dirY], cmm=logname + " orientation, " + "time level = " + t, value=1);
//plot([dirX,dirY], value=1,ps="BDFPROSAVdirt0.eps");
//plot( [uX,uY], cmm=logname + " velocity, " + "time level = " + t, value=1);

//***************************************************************
//****************** First time-step ****************************
//***************************************************************
t = t + dT;

//Store from previous time-step, 
uXoldold = uX;      
uYoldold = uY;
poldold  = p; 
dirXoldold = dirX;
dirYoldold = dirY;
qqoldold = qq;
wXoldold = wX;
wYoldold = wY;
rroldold = rr;
//---------------------------------------------------------------	
//  u(n) <- u(n+1)
uXold = uX;      
uYold = uY;
pold  = p;
dirXold = dirX;
dirYold = dirY;
qqold = qq;
rrold = rr;
wXold = wX;
wYold = wY;
gold = g;
Hfuncold = Hfunc;

cout << "first_time" <<endl;

error = 1.0;
//errorp= 1.0;
for(numIts=0; numIts<maxItrPicard; numIts++)   //Picard iteration for AC-NS
{
	//Store from previous picard iterate, 
	uXtemp  = uX;    
	uYtemp  = uY;

	for(int i=0;i<maxItrNewton;i++)        //Newton iteration for AC nonlinear scheme
	{   
		//Store from previous newton iterate, 
		dirXtemp = dirX;
		dirYtemp = dirY;
		ACNewton1st;//P3;//		//output: correction r for
		if( sqrt((rX[].linfty)^2+(rY[].linfty)^2)< tolNewton ) break;
		//if(rX[].linfty < tolNewton && rY[].linfty < tolNewton) break;
		dirX = dirXtemp + rX; 	
		dirY = dirYtemp + rY;
	}

	NSPicard1st;//P4;//	 	//output: uX,uY,p	

   //Compute error in Picard iteration
	tmpUH1err = sqrt( int2d(ThF)(  (uX-uXtemp)^2 + (uY-uYtemp)^2 + (dx(uX)-dx(uXtemp))^2 + (dy(uY)-dy(uYtemp))^2 + (dy(uX)-dy(uXtemp))^2 + (dx(uY)-dx(uYtemp))^2 ));
	tmpUH1norm = sqrt( int2d(ThF)(  (uX)^2 + (uY)^2 + (dx(uX))^2 + (dy(uY))^2  + (dy(uX))^2 + (dx(uY))^2  ));                         
	error = tmpUH1err;                   
	
	if (error <tolPicard ) break;
}		    	  
cout << "at t = " << t << ", Picard numIts = " << numIts << endl;
//cout << "  relative error(u)   = " << tmpUH1err / tmpUH1norm << endl;
cout << "  error(u)= " << error << endl;

p = p - int2d(ThF)(p)/area;
V = 1.0;
qq = 1.0/eta^2 * (dirX^2 + dirY^2 - 1.0);
rr = exp(-t/Tf);
wX = -( dxx(dirX)+dyy(dirX) ) + qq*dirX ;
wY = -( dxx(dirY)+dyy(dirY) ) + qq*dirY ;

	
// //Energy
// energy(1) = int2d(ThF)(
				  // 0.5*lambda*(dx(dirX)^2+dy(dirX)^2+dx(dirY)^2+dy(dirY)^2) + lambda*eta^2*0.25*qq^2 
				// + 0.5*(uX^2+uY^2) + 0.5*dT^2*(dx(p)^2+dy(p)^2) 
				// );	
// Ekin(1) = int2d(ThF)( 0.5*(uX^2+uY^2) );
// Eelas(1)= int2d(ThF)( 0.5*lambda*(dx(dirX)^2+dy(dirX)^2+dx(dirY)^2+dy(dirY)^2) );
// Epen(1) = int2d(ThF)( lambda*eta^2*0.25*qq^2 );

// cout << "at t = " << t << ", orinergy = " << orienergy(1) << endl;
//cout << "at t = " << t << ", Energy = " << energy(1) << endl;
// cout << "at t = " << t << ", Ekin = " << Ekin(1) << endl;
// cout << "at t = " << t << ", Eelas = " << Eelas(1) << endl;
// cout << "at t = " << t << ", Epen = " << Epen(1) << endl;

//plot
//plot(ThF, [dirX,dirY], cmm=logname + " orientation, " + "time level = " + t, value=1);
//plot(ThF, [uX,uY], cmm=logname + " velocity, " + "time level = " + t, value=1);
//initialize real-time clock tracker
real outputCLOCK;	
real loopt;
outputCLOCK = clock();	


//***************************************************************
//****************** coupled system time loop ******************
//***************************************************************
for ( int i=2 ; i <=Numdt ; i++){
	loopt = clock();
	t = t + dT;
	cout << endl << "NUMERICAL TIME LEVEL  t = " << t << endl;	
	
	//Store from previous time-step, 
	//  u(n) <- u(n+1)
	uXold = uX;      
	uYold = uY;
	pold  = p;
	dirXold = dirX;//d_2nd
	dirYold = dirY;
	qqold = qq;
	rrold = rr;
	wXold = wX;
	wYold = wY;
	// gold = g;
	// Hfuncold = Hfunc;
	
	//utilde dtilde wtilde
	utildeX = 2.0* uXold - uXoldold;
	utildeY = 2.0* uYold - uYoldold;
	dirtildeX = 2.0* dirXold - dirXoldold;
	dirtildeY = 2.0* dirYold - dirYoldold;
	wtildeX = 2.0* wXold - wXoldold;
	wtildeY = 2.0* wYold - wYoldold;
	
	//solve problem
	solveDhat;//output: dirhatX dirhatY
	solveDbreve;//output: dirbreveX dirbreveY
	solveUstarhat;//output: ustarhatX ustarhatY
	solveUstarbreve;//output: ustarbreveX ustarbreveY
	solvePhat;//output: phat
	solvePbreve;//output: pbreve
	solveUhat;//output: uhat
	solveUbreve;//output: ubreve
	
	
	whatX = -(3.0*dirhatX - 4.0*dirXold + dirXoldold)/ (2.0*M*dT);
	whatY = -(3.0*dirhatY - 4.0*dirYold + dirYoldold)/ (2.0*M*dT);
	wbreveX = -1.0 / M * (1.5*dirbreveX/dT + Ugradv1(utildeX,utildeY,dirtildeX));
	wbreveY = -1.0 / M * (1.5*dirbreveY/dT + Ugradv1(utildeX,utildeY,dirtildeY));
	
	//V
	A = 2.0*rrold/dT*exp(-(t)/Tf)-0.5/dT*rroldold*exp(-(t)/Tf)
		+int2d(ThF)( cc( utildeX,utildeY,dirtildeX,dirtildeY,whatX,whatY ) )
		-int2d(ThF)( cc( ustarhatX,ustarhatY,dirtildeX,dirtildeY,wtildeX,wtildeY ) )
		+1.0/lambda*int2d(ThF)( cc( utildeX,utildeY,utildeX,utildeY,ustarhatX,ustarhatY ) );
	B = (1.5/dT+1.0/Tf)*exp(-2.0*t/Tf)
		-int2d(ThF)( cc( utildeX,utildeY,dirtildeX,dirtildeY,wbreveX,wbreveY ) )
		+int2d(ThF)( cc( ustarbreveX,ustarbreveY,dirtildeX,dirtildeY,wtildeX,wtildeY  ) )
		-1.0/lambda*int2d(ThF)( cc( utildeX,utildeY,utildeX,utildeY,ustarbreveX,ustarbreveY ) );
	A = A*dT;
	B = B*dT;
	V = A / B;
	cout << "at t = " << t << ", V = " << V << endl;
	
	// dirX dirY uX, uY
	dirX = dirhatX + V * dirbreveX;
	dirY = dirhatY + V * dirbreveY;
	uX = uhatX + V * ubreveX;
	uY = uhatY + V * ubreveY;
	ustarX = ustarhatX + V * ustarbreveX;
	ustarY = ustarhatY + V * ustarbreveY;
	wX = whatX + V * wbreveX;
	wY = whatY + V * wbreveY;
	rr = V * exp(-t/Tf);
	
	// cout << "at t = " << t << ", dir_norm = " << dirX^2+dirY^2 << endl;

	//p
	p = phat + V * pbreve;
	//p = p - int2d(ThF)(p)/area;
	qq = 4.0/3.0*qqold-1.0/3.0*qqoldold
		+2.0/(eta^2)*dot(dirtildeX,dirtildeY,dirX,dirY)
		-8.0/(3.0*eta^2)*dot(dirtildeX,dirtildeY,dirXold,dirYold)
		+2.0/(3.0*eta^2)*dot(dirtildeX,dirtildeY,dirXoldold,dirYoldold);
	
		//norm
	dirnorm = sqrt(dirX^2 + dirY^2);
	unorm = sqrt(uX^2 + uY^2);
	//Save dir u
	if(i==0.01/dT )   {
		ffSaveData2(dirX,dirY,"BDFPROSAVdir_t001.txt");
		ffSaveData2(uX,uY,"BDFPROSAVu_t001.txt");
		ffSaveData(unorm,"BDFPROSAVunorm_t001.txt");
		ffSaveData(dirnorm,"BDFPROSAVdirnorm_t001.txt");
		//plot([uX,uY], ps="BDFut001.eps");
	}
	
	if(i==0.05/dT )   {
		ffSaveData2(dirX,dirY,"BDFPROSAVdir_t005.txt");
		ffSaveData2(uX,uY,"BDFPROSAVu_t005.txt");
		ffSaveData(unorm,"BDFPROSAVunorm_t005.txt");
		ffSaveData(dirnorm,"BDFPROSAVdirnorm_t005.txt");
		//plot([uX,uY], ps="BDFut01.eps");
	}
	
	if(i==0.1/dT )   {
		ffSaveData2(dirX,dirY,"BDFPROSAVdir_t01.txt");
		ffSaveData2(uX,uY,"BDFPROSAVu_t01.txt");
		ffSaveData(unorm,"BDFPROSAVunorm_t01.txt");
		ffSaveData(dirnorm,"BDFPROSAVdirnorm_t01.txt");
		//plot([uX,uY], ps="BDFut01.eps");
	}
	
	if(i==0.15/dT )   {
		ffSaveData2(dirX,dirY,"BDFPROSAVdir_t015.txt");
		ffSaveData2(uX,uY,"BDFPROSAVu_t015.txt");
		ffSaveData(unorm,"BDFPROSAVunorm_t015.txt");
		ffSaveData(dirnorm,"BDFPROSAVdirnorm_t015.txt");
		//plot([uX,uY], ps="BDFut015.eps");
	}
	
	if(i==0.2/dT )   {
		ffSaveData2(dirX,dirY,"BDFPROSAVdir_t02.txt");
		ffSaveData2(uX,uY,"BDFPROSAVu_t02.txt");
		ffSaveData(unorm,"BDFPROSAVunorm_t02.txt");
		ffSaveData(dirnorm,"BDFPROSAVdirnorm_t02.txt");
		//plot([uX,uY], ps="BDFut02.eps");
	}
	
	if(i==0.25/dT )   {
		ffSaveData2(dirX,dirY,"BDFPROSAVdir_t025.txt");
		ffSaveData2(uX,uY,"BDFPROSAVu_t025.txt");
		ffSaveData(unorm,"BDFPROSAVunorm_t025.txt");
		ffSaveData(dirnorm,"BDFPROSAVdirnorm_t025.txt");
		//plot([uX,uY], ps="BDFut025.eps");
	}
	
	
	if(i==0.32/dT )   {
		ffSaveData2(dirX,dirY,"BDFPROSAVdir_t032.txt");
		ffSaveData2(uX,uY,"BDFPROSAVu_t032.txt");
		ffSaveData(unorm,"BDFPROSAVunorm_t032.txt");
		ffSaveData(dirnorm,"BDFPROSAVdirnorm_t032.txt");
		//plot([uX,uY], ps="BDFut03.eps");
	}
	
	if(i==0.33/dT )   {
		ffSaveData2(dirX,dirY,"BDFPROSAVdir_t033.txt");
		ffSaveData2(uX,uY,"BDFPROSAVu_t033.txt");
		ffSaveData(unorm,"BDFPROSAVunorm_t033.txt");
		ffSaveData(dirnorm,"BDFPROSAVdirnorm_t033.txt");
		//plot([uX,uY], ps="BDFut03.eps");
	}
	
	
	if(i==0.4/dT )   {
		ffSaveData2(dirX,dirY,"BDFPROSAVdir_t04.txt");
		ffSaveData2(uX,uY,"BDFPROSAVu_t04.txt");
		ffSaveData(unorm,"BDFPROSAVunorm_t04.txt");
		ffSaveData(dirnorm,"BDFPROSAVdirnorm_t04.txt");
		//plot([uX,uY], ps="BDFut04.eps");
	}
	
	if(i==0.5/dT )   {
		ffSaveData2(dirX,dirY,"BDFPROSAVdir_t05.txt");
		ffSaveData2(uX,uY,"BDFPROSAVu_t05.txt");
		ffSaveData(unorm,"BDFPROSAVunorm_t05.txt");
		ffSaveData(dirnorm,"BDFPROSAVdirnorm_t05.txt");
		//plot([uX,uY], ps="BDFut05.eps");
	}
	
	//g Hfuc
	// g = nu * div(ustarX,ustarY) + gold;
	// Hfunc = p + g;
	//Energy
	// energy(i) = int2d(ThF)(
				  // 0.5*(uX^2+uY^2) + 0.5*((2.0*uX-uXold)^2+(2.0*uY-uYold)^2) + 2.0*(dT)^2/3.0*(dx(Hfunc)^2+dy(Hfunc)^2)
				// + 1.0/nu*dT*g^2 + 0.5*lambda*(dx(dirX)^2+dy(dirX)^2+dx(dirY)^2+dy(dirY)^2)
				// + 0.5*lambda*(dx(dirbarX)^2+dy(dirbarX)^2+dx(dirbarY)^2+dy(dirbarY)^2)
				// + 0.25*lambda*eta^2*qq^2 + 0.25*lambda*eta^2*(2.0*qq-qqold)^2 
				// + lambda*gamma/eta^2*((dirX-dirXold)^2+(dirY-dirYold)^2)
				// + lambda*gamma1*hValue*(dx(dirmaoX)^2+dy(dirmaoX)^2+dx(dirmaoY)^2+dy(dirmaoY)^2)
				// )
				// + 0.5*lambda*rr^2 + 0.5*lambda*(2.0*rr-rrold)^2
				// ;
	
	// orienergy(i) = int2d(ThF)( 0.5*(uX^2+uY^2) + 0.5*lambda*(dx(dirX)^2+dy(dirX)^2+dx(dirY)^2+dy(dirY)^2) + lambda*eta^2*0.25*qq^2);
	// Ekin(i) = int2d(ThF)( 0.5*(uX^2+uY^2) );
	// Eelas(i)= int2d(ThF)( 0.5*lambda*(dx(dirX)^2+dy(dirX)^2+dx(dirY)^2+dy(dirY)^2) );
	// Epen(i) = int2d(ThF)( lambda*eta^2*0.25*qq^2 );
	// cout << "at t = " << t << ", orinergy = " << orienergy(i) << endl;
	//cout << "at t = " << t << ", Energy = " << energy(i) << endl;
	// cout << "at t = " << t << ", Ekin = " << Ekin(i) << endl;
	// cout << "at t = " << t << ", Eelas = " << Eelas(i) << endl;
	// cout << "at t = " << t << ", Epen = " << Epen(i) << endl;
	
	//u(n-1) <- u(n)
	uXoldold = uXold;
	uYoldold = uYold;
	poldold = pold;
	dirXoldold = dirXold;
	dirYoldold = dirYold;
	qqoldold = qqold;
	rroldold = rrold;
	wXoldold = wXold;
	wYoldold = wYold;
	
	//
	cout << endl << " *** elapsed time = " << clock() - loopt<< endl;

	plot([uX,uY], cmm=logname + " velocity, " + "time level = " + t, value=1);
	//plot([dirX,dirY], cmm=logname + " orientation, " + "time level = " + t, value=1);
	//plot(ThF, phi, cmm=logname + " Phase variable, " + "time level = " + t, value=1);
	//plot(p, cmm=logname + " Pressure, " + "time level = " + t, value=1, fill=1);
	  
	} // END WHILE OF TIME LOOP

	//interpolate solution to the base mesh, for consecutive error computation
	uXtf = uX;
	uYtf = uY;
	dirXtf = dirX;
	dirYtf = dirY;
	ptf  = p; 
{
	ofstream report(logname,append);
	report << "# Loop time # " << clock()-outputCLOCK << endl;
}
//--------report inside refinement loop, in case program terminates earilier--------
//-----------------------------------------------------------------------------------
// ofstream report(logname,append);
// report << endl << endl;
// report << "***********************************************************************" << endl;
// report << "  Energy             = " << energy << endl << endl;
// report << "  oriEnergy          = " << orienergy << endl << endl;
// report << "  Ekin             = " << Ekin << endl << endl;
// report << "  Eelas             = " << Eelas << endl << endl;
// report << "  Epen            = " << Epen << endl << endl;

